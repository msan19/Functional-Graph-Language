/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 3.5.1.0
 */

using System.CodeDom.Compiler;
using Hime.Redist;
using Hime.Redist.Parsers;

namespace LexParserLib
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	[GeneratedCode("Hime.SDK", "3.5.1.0")]
	internal class GrammarParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		private static readonly LRkAutomaton commonAutomaton = LRkAutomaton.Find(typeof(GrammarParser), "GrammarParser.bin");
		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		[GeneratedCode("Hime.SDK", "3.5.1.0")]
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable Prog
			/// </summary>
			public const int VariableProg = 0x0008;
			/// <summary>
			/// The unique identifier for variable Declarations
			/// </summary>
			public const int VariableDeclarations = 0x0009;
			/// <summary>
			/// The unique identifier for variable Declaration
			/// </summary>
			public const int VariableDeclaration = 0x000A;
			/// <summary>
			/// The unique identifier for variable Func
			/// </summary>
			public const int VariableFunc = 0x000B;
			/// <summary>
			/// The unique identifier for variable FuncTypeDecl
			/// </summary>
			public const int VariableFuncTypeDecl = 0x000C;
			/// <summary>
			/// The unique identifier for variable Types
			/// </summary>
			public const int VariableTypes = 0x000D;
			/// <summary>
			/// The unique identifier for variable Type
			/// </summary>
			public const int VariableType = 0x000E;
			/// <summary>
			/// The unique identifier for variable Ids
			/// </summary>
			public const int VariableIds = 0x000F;
			/// <summary>
			/// The unique identifier for variable Expression
			/// </summary>
			public const int VariableExpression = 0x0010;
			/// <summary>
			/// The unique identifier for variable Term
			/// </summary>
			public const int VariableTerm = 0x0011;
			/// <summary>
			/// The unique identifier for variable Factor
			/// </summary>
			public const int VariableFactor = 0x0012;
			/// <summary>
			/// The unique identifier for variable Exponent
			/// </summary>
			public const int VariableExponent = 0x0013;
			/// <summary>
			/// The unique identifier for variable Expressions
			/// </summary>
			public const int VariableExpressions = 0x0014;
			/// <summary>
			/// The unique identifier for variable Literal
			/// </summary>
			public const int VariableLiteral = 0x0015;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0008, "Prog"), 
			new Symbol(0x0009, "Declarations"), 
			new Symbol(0x000A, "Declaration"), 
			new Symbol(0x000B, "Func"), 
			new Symbol(0x000C, "FuncTypeDecl"), 
			new Symbol(0x000D, "Types"), 
			new Symbol(0x000E, "Type"), 
			new Symbol(0x000F, "Ids"), 
			new Symbol(0x0010, "Expression"), 
			new Symbol(0x0011, "Term"), 
			new Symbol(0x0012, "Factor"), 
			new Symbol(0x0013, "Exponent"), 
			new Symbol(0x0014, "Expressions"), 
			new Symbol(0x0015, "Literal"), 
			new Symbol(0x0026, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {
 };
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public GrammarParser(GrammarLexer lexer) : base (commonAutomaton, variables, virtuals, null, lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		[GeneratedCode("Hime.SDK", "3.5.1.0")]
		public class Visitor
		{
			public virtual void OnTerminalId(ASTNode node) {}
			public virtual void OnTerminalRealNumber(ASTNode node) {}
			public virtual void OnTerminalIntegerNumber(ASTNode node) {}
			public virtual void OnTerminalWhiteSpace(ASTNode node) {}
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnVariableProg(ASTNode node) {}
			public virtual void OnVariableDeclarations(ASTNode node) {}
			public virtual void OnVariableDeclaration(ASTNode node) {}
			public virtual void OnVariableFunc(ASTNode node) {}
			public virtual void OnVariableFuncTypeDecl(ASTNode node) {}
			public virtual void OnVariableTypes(ASTNode node) {}
			public virtual void OnVariableType(ASTNode node) {}
			public virtual void OnVariableIds(ASTNode node) {}
			public virtual void OnVariableExpression(ASTNode node) {}
			public virtual void OnVariableTerm(ASTNode node) {}
			public virtual void OnVariableFactor(ASTNode node) {}
			public virtual void OnVariableExponent(ASTNode node) {}
			public virtual void OnVariableExpressions(ASTNode node) {}
			public virtual void OnVariableLiteral(ASTNode node) {}
		}

		/// <summary>
		/// Walk the ASTLib of a result using a visitor
		/// <param name="result">The parse result</param>
		/// <param name="visitor">The visitor to use</param>
		/// </summary>
		public static void Visit(ParseResult result, Visitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the sub-ASTLib from the specified node using a visitor
		/// </summary>
		/// <param name="node">The ASTLib node to start from</param>
		/// <param name="visitor">The visitor to use</param>
		public static void VisitASTNode(ASTNode node, Visitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0003: visitor.OnTerminalId(node); break;
				case 0x0004: visitor.OnTerminalRealNumber(node); break;
				case 0x0005: visitor.OnTerminalIntegerNumber(node); break;
				case 0x0006: visitor.OnTerminalWhiteSpace(node); break;
				case 0x0007: visitor.OnTerminalSeparator(node); break;
				case 0x0008: visitor.OnVariableProg(node); break;
				case 0x0009: visitor.OnVariableDeclarations(node); break;
				case 0x000A: visitor.OnVariableDeclaration(node); break;
				case 0x000B: visitor.OnVariableFunc(node); break;
				case 0x000C: visitor.OnVariableFuncTypeDecl(node); break;
				case 0x000D: visitor.OnVariableTypes(node); break;
				case 0x000E: visitor.OnVariableType(node); break;
				case 0x000F: visitor.OnVariableIds(node); break;
				case 0x0010: visitor.OnVariableExpression(node); break;
				case 0x0011: visitor.OnVariableTerm(node); break;
				case 0x0012: visitor.OnVariableFactor(node); break;
				case 0x0013: visitor.OnVariableExponent(node); break;
				case 0x0014: visitor.OnVariableExpressions(node); break;
				case 0x0015: visitor.OnVariableLiteral(node); break;
			}
		}
	}
}
